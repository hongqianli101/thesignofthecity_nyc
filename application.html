<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>The Sign of the City</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="images/do not enter sign.png">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <link rel="stylesheet" href="style.css">
    <style>
        /* 隐藏浏览器滚动条 */
        html, body {
            overflow: hidden;
            height: 100%;
        }
        body::-webkit-scrollbar {
            display: none;
        }
        body {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        #barcontainer {
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        #barcontainer img {
            -webkit-user-drag: none;
            pointer-events: none;
        }
        #barcontainer:active {
            cursor: grabbing;
        }
        .bar {
            transition: left 0.15s ease-out, width 0.3s ease-out;
            will-change: left, width;
        }
        .bar.no-transition {
            transition: none !important;
        }
        .bar.expanded {
            transition: left 0.15s ease-out, width 0.3s ease-out;
        }
        .community {
            transition: left 0.15s ease-out, width 0.15s ease-out;
            will-change: left, width;
        }
        .community.no-transition {
            transition: none !important;
        }

        /* 滚动指示器样式 */
        #scroll-indicator {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30px;
            background: #111;
            z-index: 1000;
            cursor: pointer;
        }
        #scroll-indicator .track {
            position: absolute;
            top: 50%;
            left: 20px;
            right: 20px;
            height: 4px;
            background: #333;
            transform: translateY(-50%);
            border-radius: 2px;
        }
        #scroll-indicator .thumb {
            position: absolute;
            top: 50%;
            height: 10px;
            min-width: 30px;
            background: #666;
            border-radius: 5px;
            transform: translateY(-50%);
            cursor: grab;
            transition: background 0.2s, height 0.2s;
        }
        #scroll-indicator .thumb:hover {
            background: #888;
            height: 14px;
        }
        #scroll-indicator .thumb:active {
            cursor: grabbing;
            background: #4effaf;
        }
        #scroll-indicator .position-text {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #666;
            font-size: 10px;
            font-family: Arial, sans-serif;
        }
    </style>
</head>
<body>
<div class="menu">
    <div id="leftmenu">
        <h1><a href="application.html">The Sign of the City</a></h1>
    <select id="languageDropdown" style="display: none;">
        <option value="All">All Languages</option>
        <option value="English">English</option>
        <option value="Non-English">Non-English</option>
        <option value="Spanish">Spanish</option>
        <option value="Chinese">Chinese</option>
        <option value="Italian">Italian</option>
        <option value="French">French</option>
        <option value="Korean">Korean</option>
        <option value="Russian">Russian</option>
        <option value="Bengali">Bengali</option>
        <option value="Haitian Creole">Haitian Creole</option>
    </select>
    <select id="categoryDropdown" style="display: none;">
        <option value="All Categories">All Categories</option>
        <option value="Brand Sign">Brand Sign</option>
        <option value="Street Name Sign">Street Name Sign</option>
        <option value="Building Information Sign">Building Information Sign</option>
        <option value="Bus Stop Sign">Bus Stop Sign</option>
        <option value="Parking Regulation Sign">Parking Regulation Sign</option>
        <option value="Scaffold Sign">Scaffold Sign</option>
        <option value="One Way Sign">One Way Sign</option>
        <option value="Advertising Sign">Advertising Sign</option>
        <option value="For Lease Sign">For Lease Sign</option>
        <option value="Do Not Enter Sign">Do Not Enter Sign</option>
        <option value="Speed Limit Sign">Speed Limit Sign</option>
        <option value="Promotion Sign">Promotion Sign</option>
        <option value="Direction Sign">Direction Sign</option>
        <option value="Subway Sign">Subway Sign</option>
        <option value="Touristic Sign">Touristic Sign</option>
        <option value="Shop Information Sign">Shop Information Sign</option>
        <option value="Street Close Sign">Street Close Sign</option>
        <option value="School Crossing Sign">School Crossing Sign</option>
        <option value="All Traffic Sign">All Traffic Sign</option>
        <option value="Don't Block Sign">Don't Block Sign</option>
    </select>
    <input type="text" id="searchBar" placeholder="Search text..." style="display: none;"><button id="searchButton" style="display: none;">Search</button>
    </div>
    <div id="rightmenu">
    <a href="index.html">About</a>
    <span>‧</span>
    <a href="sign_category.html">Sign Category</a>
    <span>‧</span>
    <a href="sign_language.html">Sign Language</a>
    <span>‧</span>
    <a href="sign_content.html">Sign Content</a>
    </div>
</div>

<div id="barcontainer"></div>

<!-- 滚动指示器 -->
<div id="scroll-indicator">
    <div class="track"></div>
    <div class="thumb"></div>
</div>

<script type="text/javascript">
// ============================================
// InteractionController Class (On Broadway Style - Zoom/Browse Mode)
// ============================================
class InteractionController {
    constructor(container) {
        this.container = container;
        this.data = [];
        this.bars = null;

        // 基础尺寸参数
        this.baseWidth = 10;           // 基础宽度
        this.baseGap = 4;              // 基础间距（未使用，保留兼容）
        this.minGap = 1.8;             // 最小间距 (px)
        this.maxGap = 6;               // 最大间距 (px)
        this.expandedWidth = 240;      // 展开宽度（固定像素值）

        // 视图状态
        this.viewState = {
            offset: 0,
            scale: 0.6,                // 初始缩放值
            velocity: 0,
            isAnimating: false
        };

        // ========================================
        // On Broadway 风格的动画参数
        // ========================================
        this.TWEEN_TIME = 500;           // 动画持续时间 (ms)
        this.INERTIA_MULTIPLIER = 25;    // 惯性速度倍数
        this.FRICTION = 0.93;            // 摩擦系数 (0.92-0.95)
        this.MIN_VELOCITY = 0.5;         // 最小速度阈值
        this.BOUNCE_FRICTION = 0.3;      // 边界弹性系数

        // 缩放限制
        this.minScale = 0.6;
        this.maxScale = 2.5;

        // Browse 模式阈值 (scale >= maxScale * 0.95 时进入 browse 模式)
        this.browseModeThreshold = 0.95;

        // Gap 计算缓存
        this._cachedGap = this.minGap;

        // 惯性动画
        this.inertiaAnimationId = null;
        this.velocityHistory = [];
        this.lastPanTime = 0;

        // 拖拽状态
        this.isDragging = false;
        this.panStartOffset = 0;

        // 缩放状态
        this.pinchStartScale = 1;
        this.pinchStartOffset = 0;
        this.pinchCenterX = 0;

        // 缩放动画状态
        this.scaleAnimationId = null;

        // 滚动指示器
        this.scrollIndicator = {
            track: null,
            thumb: null,
            isDragging: false
        };

        // 当前中心 bar 索引（用于 browse 模式）
        this.centerBarIndex = 0;
    }

    // ========================================
    // 加载数据并初始化
    // ========================================
    loadData(data) {
        this.data = data;
        this.createBars();
        this.initHammer();
        this.initMouseWheel();
        this.initKeyboard();
        this.initScrollIndicator();
        this.updateBarsPosition();
        this.createCommunityOverlays();
        this.updateScrollIndicator();
    }

    // ========================================
    // 模式判断方法
    // ========================================

    // 判断是否在 browse 模式
    isInBrowseMode() {
        return this.viewState.scale >= this.maxScale * this.browseModeThreshold;
    }

    // 计算当前 gap（根据 scale 线性插值，范围 minGap 到 maxGap）
    getCurrentGap() {
        const scaleRatio = (this.viewState.scale - this.minScale) / (this.maxScale - this.minScale);
        return this.minGap + scaleRatio * (this.maxGap - this.minGap);
    }

    // 获取当前中心 bar 的索引
    getCenterBarIndex() {
        if (this.data.length === 0) return 0;

        const screenCenterX = window.innerWidth / 2;
        const currentWidth = this.baseWidth * this.viewState.scale;
        const currentGap = this.getCurrentGap();

        // 计算每个 bar 到屏幕中心的距离，找出最近的
        // 使用所有 bar 都是基础宽度来计算（不考虑展开状态）
        let closestIndex = 0;
        let minDistance = Infinity;

        for (let i = 0; i < this.data.length; i++) {
            // 计算 bar 的左边位置（假设所有 bar 都是基础宽度）
            const barLeft = this.viewState.offset + i * (currentWidth + currentGap);
            // 使用 bar 的左边缘来判断（而不是中心），这样更准确
            const barCenterX = barLeft + currentWidth / 2;
            const distance = Math.abs(barCenterX - screenCenterX);

            if (distance < minDistance) {
                minDistance = distance;
                closestIndex = i;
            }
        }

        // 由于展开的 bar 会向右偏移后续 bar，实际中心可能偏左一个
        // 检查是否需要调整：如果当前选中的 bar 左边缘已经超过屏幕中心，选择前一个
        if (closestIndex > 0) {
            const barLeft = this.viewState.offset + closestIndex * (currentWidth + currentGap);
            if (barLeft > screenCenterX) {
                closestIndex--;
            }
        }

        return closestIndex;
    }

    // 获取指定索引 bar 的宽度
    getBarWidth(index) {
        const baseWidthScaled = this.baseWidth * this.viewState.scale;

        if (!this.isInBrowseMode()) {
            // Zoom 模式：所有 bar 宽度相同
            return baseWidthScaled;
        } else {
            // Browse 模式：中心 bar 展开，其他保持窄
            const centerIndex = this.getCenterBarIndex();
            return index === centerIndex ? this.expandedWidth : baseWidthScaled;
        }
    }

    // ========================================
    // 创建 bar 元素
    // ========================================
    createBars() {
        this.bars = d3.select(this.container).selectAll(".bar")
            .data(this.data)
            .enter().append("div")
            .attr("class", "bar")
            .attr("data-id", d => d.id)
            .attr("data-index", (d, i) => i)
            .style("top", "24px")
            .style("height", "1000px");

        this.bars.each(function(d) {
            const selection = d3.select(this);
            selection.append("img").attr("src", d.e_image_s);
            const firstTextContainer = selection.append("div").attr("class", "text-container");
            firstTextContainer.append("p").text(d.e_text);
            selection.append("div").attr("class", "titletext").append("p").text('Category');
            selection.append("img").attr("src", d.e_image_c);
            selection.append("div").attr("class", "titletext").append("p").text('Language');
            selection.append("img").attr("src", d.e_image_l);
            selection.append("div").attr("class", "titletext").append("p").text('Meidan household income');
            selection.append("img").attr("src", d.image_h);
            selection.append("div").attr("class", "titletext").append("p").text('Race');
            selection.append("img").attr("src", d.image_d);
            selection.append("div").attr("class", "titletext").append("p").text('Language');
            selection.append("img").attr("src", d.w_image_l);
            selection.append("div").attr("class", "titletext").append("p").text('Category');
            selection.append("img").attr("src", d.w_image_c);
            const secondTextContainer = selection.append("div").attr("class", "text-container");
            secondTextContainer.append("p").text(d.w_text);
            selection.append("img").attr("src", d.w_image_s);
        });

        // 移除点击展开功能 - browse 模式下自动展开中心 bar
    }

    // ========================================
    // 初始化 Hammer.js 手势
    // ========================================
    initHammer() {
        const hammer = new Hammer(document.querySelector(this.container));

        // 启用所有方向的 pan
        hammer.get('pan').set({ direction: Hammer.DIRECTION_HORIZONTAL, threshold: 5 });

        // 启用 pinch
        hammer.get('pinch').set({ enable: true });

        // 启用双击
        hammer.get('tap').set({ taps: 2 });

        // Pan 开始
        hammer.on('panstart', (e) => {
            this.stopAllAnimations();
            this.isDragging = true;
            this.panStartOffset = this.viewState.offset;
            this.velocityHistory = [];
            this.lastPanTime = Date.now();

            // 禁用过渡动画
            d3.selectAll('.bar, .community').classed('no-transition', true);
        });

        // Pan 移动
        hammer.on('panmove', (e) => {
            const now = Date.now();
            const dt = now - this.lastPanTime;

            if (dt > 0) {
                // 使用 Hammer 提供的速度，乘以惯性倍数
                const velocity = e.velocityX * this.INERTIA_MULTIPLIER;
                this.velocityHistory.push({ velocity, time: now });

                // 只保留最近 100ms 的速度记录（用于计算平均值）
                this.velocityHistory = this.velocityHistory.filter(v => now - v.time < 100);
            }

            this.lastPanTime = now;

            // 应用软边界（拖拽时允许超出，但有阻力）
            const rawOffset = this.panStartOffset + e.deltaX;
            this.viewState.offset = this.applySoftBounds(rawOffset);

            this.updateBarsPosition();
            this.updateScrollIndicator();
        });

        // Pan 结束
        hammer.on('panend', (e) => {
            // 重新启用过渡动画
            d3.selectAll('.bar, .community').classed('no-transition', false);

            // 检查是否超出边界，如果是则弹回
            if (this.isOutOfBounds()) {
                this.bounceBack();
            } else {
                // 计算平均速度并启动惯性
                if (this.velocityHistory.length > 0) {
                    // 使用加权平均，最近的速度权重更大
                    let totalWeight = 0;
                    let weightedSum = 0;
                    const now = Date.now();

                    this.velocityHistory.forEach(v => {
                        const age = now - v.time;
                        const weight = Math.max(0, 1 - age / 100);  // 越新权重越大
                        weightedSum += v.velocity * weight;
                        totalWeight += weight;
                    });

                    const avgVelocity = totalWeight > 0 ? weightedSum / totalWeight : 0;
                    this.viewState.velocity = avgVelocity;

                    if (Math.abs(this.viewState.velocity) > this.MIN_VELOCITY) {
                        this.startInertia();
                    }
                }
            }

            setTimeout(() => {
                this.isDragging = false;
            }, 50);
        });

        // Pinch 开始
        hammer.on('pinchstart', (e) => {
            this.stopAllAnimations();
            this.pinchStartScale = this.viewState.scale;
            this.pinchStartOffset = this.viewState.offset;
            this.pinchCenterX = e.center.x;

            d3.selectAll('.bar, .community').classed('no-transition', true);
        });

        // Pinch 移动
        hammer.on('pinchmove', (e) => {
            const newScale = this.pinchStartScale * e.scale;
            this.setScaleImmediate(newScale, this.pinchCenterX);
        });

        // Pinch 结束
        hammer.on('pinchend', () => {
            d3.selectAll('.bar, .community').classed('no-transition', false);

            // 如果超出边界，弹回
            if (this.isOutOfBounds()) {
                this.bounceBack();
            }
        });

        // 双击缩放
        hammer.on('tap', (e) => {
            if (e.tapCount === 2) {
                this.handleDoubleTap(e.center.x);
            }
        });
    }

    // ========================================
    // 初始化鼠标滚轮
    // ========================================
    initMouseWheel() {
        document.querySelector(this.container).addEventListener('wheel', (event) => {
            event.preventDefault();
            this.stopAllAnimations();

            const mouseX = event.clientX;

            // 垂直滚动 = 缩放（或在最大缩放时平移）
            if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
                const zoomFactor = event.deltaY > 0 ? 0.92 : 1.08;
                const targetScale = this.viewState.scale * zoomFactor;

                // 如果已经达到最大缩放，继续向上滚动变成向左平移
                if (this.viewState.scale >= this.maxScale && event.deltaY < 0) {
                    // 向上滚动（放大方向）变成向左平移
                    this.viewState.offset -= Math.abs(event.deltaY) * 2;
                    if (this.isOutOfBounds()) {
                        this.viewState.offset = this.applySoftBounds(this.viewState.offset);
                    }
                    this.updateBarsPosition();
                    this.updateScrollIndicator();
                }
                // 如果已经达到最小缩放，继续向下滚动变成向右平移
                else if (this.viewState.scale <= this.minScale && event.deltaY > 0) {
                    // 向下滚动（缩小方向）变成向右平移
                    this.viewState.offset += Math.abs(event.deltaY) * 2;
                    if (this.isOutOfBounds()) {
                        this.viewState.offset = this.applySoftBounds(this.viewState.offset);
                    }
                    this.updateBarsPosition();
                    this.updateScrollIndicator();
                }
                else {
                    // 正常缩放
                    this.setScaleImmediate(targetScale, mouseX);
                }
            }
            // 水平滚动 = 平移（MacBook 双指左右滑动）
            else {
                this.viewState.offset -= event.deltaX;
                if (this.isOutOfBounds()) {
                    this.viewState.offset = this.applySoftBounds(this.viewState.offset);
                }
                this.updateBarsPosition();
                this.updateScrollIndicator();
            }
        }, { passive: false });
    }

    // ========================================
    // 初始化键盘控制
    // ========================================
    initKeyboard() {
        window.addEventListener('keydown', (event) => {
            switch(event.key) {
                case 'ArrowRight':
                    // 向右滑动
                    this.animateOffset(this.viewState.offset - 200);
                    break;
                case 'ArrowLeft':
                    // 向左滑动
                    this.animateOffset(this.viewState.offset + 200);
                    break;
                case '=':
                case '+':
                    this.animateScale(this.viewState.scale * 1.3, window.innerWidth / 2);
                    break;
                case '-':
                case '_':
                    this.animateScale(this.viewState.scale * 0.7, window.innerWidth / 2);
                    break;
            }
        });
    }

    // ========================================
    // 初始化滚动指示器
    // ========================================
    initScrollIndicator() {
        const indicator = document.getElementById('scroll-indicator');
        const track = indicator.querySelector('.track');
        const thumb = indicator.querySelector('.thumb');

        this.scrollIndicator.track = track;
        this.scrollIndicator.thumb = thumb;

        // 点击轨道快速跳转
        track.addEventListener('click', (e) => {
            const rect = track.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const ratio = clickX / rect.width;

            const bounds = this.getBounds();
            const targetOffset = bounds.maxOffset - ratio * (bounds.maxOffset - bounds.minOffset);

            this.animateOffset(targetOffset);
        });

        // 拖拽滑块
        let dragStartX = 0;
        let dragStartOffset = 0;

        thumb.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.scrollIndicator.isDragging = true;
            dragStartX = e.clientX;
            dragStartOffset = this.viewState.offset;
            thumb.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!this.scrollIndicator.isDragging) return;

            const trackRect = track.getBoundingClientRect();
            const deltaX = e.clientX - dragStartX;
            const deltaRatio = deltaX / trackRect.width;

            const bounds = this.getBounds();
            const range = bounds.maxOffset - bounds.minOffset;

            this.viewState.offset = dragStartOffset - deltaRatio * range;
            this.viewState.offset = Math.max(bounds.minOffset, Math.min(bounds.maxOffset, this.viewState.offset));

            this.updateBarsPosition();
            this.updateScrollIndicator();
        });

        document.addEventListener('mouseup', () => {
            if (this.scrollIndicator.isDragging) {
                this.scrollIndicator.isDragging = false;
                thumb.style.cursor = 'grab';
            }
        });
    }

    // ========================================
    // 更新滚动指示器
    // ========================================
    updateScrollIndicator() {
        if (!this.scrollIndicator.thumb || !this.scrollIndicator.track) return;

        const bounds = this.getBounds();
        const range = bounds.maxOffset - bounds.minOffset;

        if (range <= 0) return;

        // 计算当前位置比例
        const currentRatio = (bounds.maxOffset - this.viewState.offset) / range;

        // 计算可见范围比例
        const screenWidth = window.innerWidth;
        const visibleRatio = Math.min(1, screenWidth / (range + screenWidth));

        // 更新滑块
        const trackRect = this.scrollIndicator.track.getBoundingClientRect();
        const trackWidth = trackRect.width;

        const thumbWidth = Math.max(30, trackWidth * visibleRatio);
        const thumbLeft = currentRatio * (trackWidth - thumbWidth);

        this.scrollIndicator.thumb.style.width = thumbWidth + 'px';
        this.scrollIndicator.thumb.style.left = (20 + Math.max(0, Math.min(trackWidth - thumbWidth, thumbLeft))) + 'px';
    }

    // ========================================
    // 改进的惯性动画 (On Broadway 风格)
    // ========================================
    startInertia() {
        this.viewState.isAnimating = true;

        const animate = () => {
            if (!this.viewState.isAnimating) return;

            // 应用摩擦系数衰减速度
            this.viewState.velocity *= this.FRICTION;
            this.viewState.offset += this.viewState.velocity;

            // 检查边界
            const bounds = this.getBounds();

            // 如果超出边界，增加额外阻力并准备弹回
            if (this.viewState.offset < bounds.minOffset) {
                this.viewState.velocity *= 0.5;  // 额外阻力
                if (Math.abs(this.viewState.velocity) < this.MIN_VELOCITY) {
                    this.stopInertia();
                    this.bounceBack();
                    return;
                }
            } else if (this.viewState.offset > bounds.maxOffset) {
                this.viewState.velocity *= 0.5;  // 额外阻力
                if (Math.abs(this.viewState.velocity) < this.MIN_VELOCITY) {
                    this.stopInertia();
                    this.bounceBack();
                    return;
                }
            }

            this.updateBarsPosition();
            this.updateScrollIndicator();

            // 速度低于阈值时停止
            if (Math.abs(this.viewState.velocity) < this.MIN_VELOCITY) {
                this.stopInertia();
                // 停止后检查是否需要弹回
                if (this.isOutOfBounds()) {
                    this.bounceBack();
                }
                return;
            }

            this.inertiaAnimationId = requestAnimationFrame(animate);
        };

        this.inertiaAnimationId = requestAnimationFrame(animate);
    }

    // 停止惯性动画
    stopInertia() {
        this.viewState.isAnimating = false;
        this.viewState.velocity = 0;
        if (this.inertiaAnimationId) {
            cancelAnimationFrame(this.inertiaAnimationId);
            this.inertiaAnimationId = null;
        }
    }

    // 停止所有动画
    stopAllAnimations() {
        this.stopInertia();
        if (this.scaleAnimationId) {
            cancelAnimationFrame(this.scaleAnimationId);
            this.scaleAnimationId = null;
        }
    }

    // ========================================
    // 缩放动画 (带缓动函数)
    // ========================================
    animateScale(targetScale, centerX, duration = this.TWEEN_TIME) {
        this.stopAllAnimations();

        const clampedTargetScale = Math.max(this.minScale, Math.min(this.maxScale, targetScale));
        const startScale = this.viewState.scale;
        const startOffset = this.viewState.offset;

        // 计算目标 offset（保持 centerX 位置不变）
        const contentX = (centerX - startOffset) / startScale;
        const targetOffset = centerX - contentX * clampedTargetScale;

        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // cubic-out 缓动函数
            const eased = 1 - Math.pow(1 - progress, 3);

            this.viewState.scale = startScale + (clampedTargetScale - startScale) * eased;
            this.viewState.offset = startOffset + (targetOffset - startOffset) * eased;

            this.updateBarsPosition();
            this.updateScrollIndicator();

            if (progress < 1) {
                this.scaleAnimationId = requestAnimationFrame(animate);
            } else {
                this.scaleAnimationId = null;
                // 动画结束后检查边界
                if (this.isOutOfBounds()) {
                    this.bounceBack();
                }
            }
        };

        this.scaleAnimationId = requestAnimationFrame(animate);
    }

    // 立即设置缩放（不带动画，用于滚轮和 pinch）
    setScaleImmediate(newScale, centerX) {
        const clampedScale = Math.max(this.minScale, Math.min(this.maxScale, newScale));

        if (clampedScale === this.viewState.scale) return;

        // 计算以 centerX 为中心的新 offset
        const contentX = (centerX - this.viewState.offset) / this.viewState.scale;
        const newOffset = centerX - contentX * clampedScale;

        this.viewState.scale = clampedScale;
        this.viewState.offset = newOffset;

        this.updateBarsPosition();
        this.updateScrollIndicator();
    }

    // ========================================
    // 边界处理
    // ========================================

    // 获取边界值
    getBounds() {
        const currentWidth = this.baseWidth * this.viewState.scale;
        const currentGap = this.getCurrentGap();

        // 计算总宽度（考虑 browse 模式下可能有一个展开的 bar）
        let totalWidth;
        if (this.isInBrowseMode()) {
            // Browse 模式：一个 bar 展开，其他都是基础宽度
            totalWidth = (this.data.length - 1) * (currentWidth + currentGap) + this.expandedWidth + currentGap;
        } else {
            // Zoom 模式：所有 bar 宽度相同
            totalWidth = this.data.length * (currentWidth + currentGap);
        }

        const screenWidth = window.innerWidth;

        // 内容必须贴住屏幕边缘，不留空白
        // maxOffset = 0 表示内容左边缘贴住屏幕左边缘
        // minOffset 确保内容右边缘不超过屏幕右边缘
        if (totalWidth <= screenWidth) {
            // 内容宽度小于屏幕宽度时，从左边缘开始，不能向左移动
            return {
                minOffset: 0,
                maxOffset: 0,
                totalWidth
            };
        } else {
            // 内容宽度大于屏幕宽度时
            // maxOffset = 0：最左边的bar贴住屏幕左边缘
            // minOffset = screenWidth - totalWidth：最右边的bar贴住屏幕右边缘
            return {
                minOffset: screenWidth - totalWidth,
                maxOffset: 0,
                totalWidth
            };
        }
    }

    // 检查是否超出边界
    isOutOfBounds() {
        const bounds = this.getBounds();
        return this.viewState.offset < bounds.minOffset || this.viewState.offset > bounds.maxOffset;
    }

    // 应用软边界（拖拽时的弹性效果）
    applySoftBounds(offset) {
        const bounds = this.getBounds();

        if (offset < bounds.minOffset) {
            const overflow = bounds.minOffset - offset;
            return bounds.minOffset - overflow * this.BOUNCE_FRICTION;
        }
        if (offset > bounds.maxOffset) {
            const overflow = offset - bounds.maxOffset;
            return bounds.maxOffset + overflow * this.BOUNCE_FRICTION;
        }
        return offset;
    }

    // 边界回弹动画
    bounceBack() {
        const bounds = this.getBounds();
        let targetOffset = this.viewState.offset;

        if (this.viewState.offset < bounds.minOffset) {
            targetOffset = bounds.minOffset;
        } else if (this.viewState.offset > bounds.maxOffset) {
            targetOffset = bounds.maxOffset;
        }

        if (targetOffset !== this.viewState.offset) {
            this.animateOffset(targetOffset, 300);  // 较短的回弹时间
        }
    }

    // ========================================
    // 更新所有 bar 的位置
    // ========================================
    updateBarsPosition() {
        const currentWidth = this.baseWidth * this.viewState.scale;
        const currentGap = this.getCurrentGap();
        const inBrowseMode = this.isInBrowseMode();
        const centerIndex = inBrowseMode ? this.getCenterBarIndex() : -1;

        // 更新当前中心 bar 索引（用于其他地方引用）
        this.centerBarIndex = centerIndex;

        this.bars.each((d, i, nodes) => {
            const bar = d3.select(nodes[i]);
            const isExpanded = inBrowseMode && i === centerIndex;

            // 计算当前 bar 的宽度
            const barWidth = this.getBarWidth(i);

            // 计算位置：需要考虑之前所有 bar 的宽度
            let leftPos = this.viewState.offset;
            for (let j = 0; j < i; j++) {
                leftPos += this.getBarWidth(j) + currentGap;
            }

            bar.style("left", leftPos + "px")
               .style("width", barWidth + "px")
               .classed("expanded", isExpanded);

            // 只有展开的 bar 才显示文字
            bar.select("p").style("display", isExpanded ? "block" : "none");
        });

        this.updateCommunityOverlays();
    }

    // ========================================
    // 滚动到指定索引的 bar（使其居中）
    // ========================================
    scrollToBar(index) {
        if (index < 0 || index >= this.data.length) return;

        const currentWidth = this.baseWidth * this.viewState.scale;
        const currentGap = this.getCurrentGap();

        // 计算 bar 的位置
        const barPosition = index * (currentWidth + currentGap);
        const targetOffset = (window.innerWidth / 2) - barPosition - (currentWidth / 2);

        this.animateOffset(targetOffset);
    }

    // ========================================
    // 平滑动画到目标 offset
    // ========================================
    animateOffset(targetOffset, duration = this.TWEEN_TIME) {
        this.stopAllAnimations();

        // 应用边界限制
        const bounds = this.getBounds();
        targetOffset = Math.max(bounds.minOffset, Math.min(bounds.maxOffset, targetOffset));

        const startOffset = this.viewState.offset;
        const distance = targetOffset - startOffset;
        const startTime = performance.now();

        const animate = (currentTime) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);

            // cubic-out 缓动函数
            const eased = 1 - Math.pow(1 - progress, 3);

            this.viewState.offset = startOffset + distance * eased;
            this.updateBarsPosition();
            this.updateScrollIndicator();

            if (progress < 1) {
                this.inertiaAnimationId = requestAnimationFrame(animate);
            } else {
                this.inertiaAnimationId = null;
            }
        };

        this.inertiaAnimationId = requestAnimationFrame(animate);
    }

    // ========================================
    // 双击缩放处理
    // ========================================
    handleDoubleTap(centerX) {
        // 双击切换：如果未在 browse 模式，进入 browse 模式（放大到接近 maxScale）
        // 如果已在 browse 模式，缩小回 minScale
        if (this.isInBrowseMode()) {
            // 在 browse 模式，缩小回初始状态
            this.animateScale(this.minScale, centerX, 400);
        } else {
            // 放大到 browse 模式
            this.animateScale(this.maxScale, centerX, 400);
        }
    }

    // ========================================
    // 创建社区覆盖层
    // ========================================
    createCommunityOverlays() {
        const communities = d3.group(this.data, d => d.community);

        communities.forEach((bars, communityName) => {
            const firstBar = bars[0];
            const firstBarIndex = this.data.findIndex(d => d.id === firstBar.id);

            d3.select(this.container).append("div")
                .attr("class", "community")
                .attr("data-community", communityName)
                .style("top", "0px")
                .style("height", "20px")
                .style("border", "none")
                .style("border-left", "2px solid white")
                .text(communityName)
                .on("click", () => {
                    this.scrollToBar(firstBarIndex);
                });
        });

        this.updateCommunityOverlays();
    }

    // 更新社区覆盖层位置
    updateCommunityOverlays() {
        if (this.data.length === 0) return;

        const communities = d3.group(this.data, d => d.community);

        communities.forEach((bars, communityName) => {
            const firstBar = bars[0];
            const lastBar = bars[bars.length - 1];

            const firstBarDiv = d3.select(`.bar[data-id="${firstBar.id}"]`);
            const lastBarDiv = d3.select(`.bar[data-id="${lastBar.id}"]`);

            if (firstBarDiv.empty() || lastBarDiv.empty()) return;

            const firstBarLeft = parseFloat(firstBarDiv.style("left"));
            const lastBarRight = parseFloat(lastBarDiv.style("left")) + parseFloat(lastBarDiv.style("width"));
            const communityWidth = lastBarRight - firstBarLeft;

            d3.select(`.community[data-community="${communityName}"]`)
                .style("left", firstBarLeft + "px")
                .style("width", communityWidth + "px");
        });
    }
}

// ============================================
// 筛选功能
// ============================================
function setupFilters() {
    const searchBar = document.getElementById("searchBar");
    const searchButton = document.getElementById("searchButton");
    const languageDropdown = document.getElementById("languageDropdown");
    const categoryDropdown = document.getElementById("categoryDropdown");

    // 搜索功能
    function performSearch() {
        const searchText = searchBar.value.toLowerCase();

        d3.select("#barcontainer").selectAll(".bar")
            .classed("show", function(d) {
                const matchText = d.e_text.toLowerCase().includes(searchText) || d.w_text.toLowerCase().includes(searchText);
                return matchText;
            })
            .classed("hide", function(d) {
                const matchText = d.e_text.toLowerCase().includes(searchText) || d.w_text.toLowerCase().includes(searchText);
                return !matchText;
            });
    }

    searchButton.addEventListener("click", performSearch);
    searchBar.addEventListener("keypress", (e) => {
        if (e.key === "Enter") performSearch();
    });

    // 语言筛选
    function filterByLanguage() {
        const selectedLanguage = languageDropdown.value;

        d3.select("#barcontainer").selectAll(".bar")
            .classed("show", function(d) {
                const hasLanguage = d.language_full && d.language_full.trim().length > 0;

                if (selectedLanguage === "All") {
                    return true;
                } else if (selectedLanguage === "Non-English") {
                    return hasLanguage && !d.language_full.toLowerCase().includes("english");
                } else {
                    return hasLanguage && d.language_full.toLowerCase().includes(selectedLanguage.toLowerCase());
                }
            })
            .classed("hide", function(d) {
                const hasLanguage = d.language_full && d.language_full.trim().length > 0;

                if (selectedLanguage === "All") {
                    return false;
                } else if (selectedLanguage === "Non-English") {
                    return !hasLanguage || d.language_full.toLowerCase().includes("english");
                } else {
                    return !hasLanguage || !d.language_full.toLowerCase().includes(selectedLanguage.toLowerCase());
                }
            });
    }

    languageDropdown.addEventListener("change", filterByLanguage);

    // 分类筛选
    function filterByCategory() {
        const selectedCategory = categoryDropdown.value.toLowerCase();

        d3.select("#barcontainer").selectAll(".bar")
            .classed("show", function(d) {
                if (selectedCategory === "all categories") return true;
                return d.category.includes(selectedCategory);
            })
            .classed("hide", function(d) {
                if (selectedCategory === "all categories") return false;
                return !d.category.includes(selectedCategory);
            });
    }

    categoryDropdown.addEventListener("change", filterByCategory);
}

// ============================================
// 初始化
// ============================================
let controller = null;

document.addEventListener('DOMContentLoaded', () => {
    controller = new InteractionController("#barcontainer");

    d3.json("data_final.json").then(function(data) {
        controller.loadData(data);
        setupFilters();
    }).catch(function(error) {
        console.error("Error loading data:", error);
    });
});
</script>
</body>
</html>